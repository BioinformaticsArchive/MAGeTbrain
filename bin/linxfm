#! /usr/bin/env perl
#
# Andrew Janke - a.janke@gmail.com
#
# Copyright Andrew Janke, The University of Queensland.
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies.
# The author and the University make no representations about the
# suitability of this software for any purpose.  It is provided "as is"
# without express or implied warranty.
#
# Take a stab at averaging a number of xfms using
# Matrix logs and exponents (currently forks Octave)
#
# this bit works I just have to add some code to check for equal linear components
# Or get _REAL_ clever and resample the nonlinear grids by the average transform
# minus their original transform....  both are possible but I can bet which one
# I'll do...... :)


$| = 0;

use strict;
use warnings "all";
use Getopt::Tabular;
use File::Basename;
use File::Temp qw/ tempdir /;

# until I get organised and do this properly
my $PACKAGE = &basename($0);
my $VERSION = '1.0.0';
my $PACKAGE_BUGREPORT = '"Andrew Janke" <a.janke@gmail.com>';

# identity matrix
my(@ident) = (1, 0, 0, 0, 
              0, 1, 0, 0,
              0, 0, 1, 0);

my($Help, $Usage, $me, @opt_table, $tmpdir, $history, %opt);
my(@args, $args, @in_xfms, $out_xfm);

# Argument variables and table
$me = &basename($0);
%opt = (
   'verbose' => 0,
   'clobber' => 0
    );

$Help = <<HELP;
| $me extracts the linear transform from an xfm.
|
| This program is based on xfmavg by a janke. 
|
HELP

$Usage = "Usage: $me [options] <in1.xfm> <out.xfm>\n".
         "       $me -help to list options\n\n";

@opt_table = (
   ["General Options", "section" ],
   ["-version", "call", 0, \&print_version_info,
      "print version and exit" ],
   ["-clobber", "boolean", 0, \$opt{'clobber'},
      "clobber existing files"],
   );

# get history string
chomp($history = `date`);
$history .= '>>>> ' . join(' ', $me, @ARGV);

# check arguments
&Getopt::Tabular::SetHelp($Help, $Usage);
&GetOptions (\@opt_table, \@ARGV) || exit 1;
die $Usage if ($#ARGV < 1);
$out_xfm = pop(@ARGV);
@in_xfms = @ARGV;

# make tmpdir
$tmpdir = &tempdir( "$me-XXXXXXXX", TMPDIR => 1, CLEANUP => 1 );

# check for the output xfm
if(-e $out_xfm && !$opt{'clobber'}){ 
   die "$me: $out_xfm exists! use -clobber to overwrite\n\n"; 
   }

# parse the input transforms
my(@first_xfm, $filec, $xfm_file, @varnames, @nl_xfms, 
   @arr, $dump, @dump, $c, $i, $prefix);

$filec = 0;
foreach $xfm_file (@in_xfms){
   
   # check for the xfm
   if(!-e $xfm_file){ 
      die "$me: Couldn't find $xfm_file\n"; 
      }
   
   if($opt{'verbose'}){
      print STDOUT "Parsing $xfm_file\n";
      }
   
   $c = 0;
   @dump = `cat $xfm_file`;
   $varnames[$filec] = sprintf("A%03d", $filec);
   
   # find and read in the linear tranformation
   while($dump[$c] !~ /Linear\_Transform\ \=/){
      $c++;
      }
   $c++;


   # get the transformation matrix
   for($i = 0; $i<3; $i++, $c++){
      chomp($dump[$c]);
      $dump[$c] =~ s/\;$//;
      ($arr[($i*4)+0],
       $arr[($i*4)+1],
       $arr[($i*4)+2],
       $arr[($i*4)+3]) = split(' ', $dump[$c], 4);
      }

   # write the output xfm
   open(XFM, ">$out_xfm");
   print XFM "MNI Transform File\n" .
             "%\n" .
             "% Created by $me.\n" .
             "%\n" .
             "% $history \n" .
             "\n" .
             "Transform_Type = Linear;\n" .
             "Linear_Transform =\n" .
             "$arr[0]  $arr[1]  $arr[2]   $arr[3]\n" .
             "$arr[4]  $arr[5]  $arr[6]   $arr[7]\n" .
             "$arr[8]  $arr[9]  $arr[10]  $arr[11];\n"; 
   close(XFM);
}

sub print_version_info {
   print STDOUT "\n$PACKAGE version $VERSION\n".
                "Comments to $PACKAGE_BUGREPORT\n\n";
   exit;
   }
