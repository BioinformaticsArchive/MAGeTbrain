#!/usr/bin/env python2.7
from itertools import product, chain
from collections import defaultdict
from multiprocessing.dummy import Pool
from subprocess import call
import os, errno, random, glob, sys
import os.path


# infrastructure 

def mkdir_p(path):
  try:
    os.makedirs(path)
  except OSError as exc: # Python >2.5
    if exc.errno == errno.EEXIST and os.path.isdir(path):
      pass
    else: raise

class datafile: 
  def __init__(self, path): 
    self.path = path 
    self.abspath = os.path.abspath(path)
    self.basename = os.path.basename(path)
    self.dirname = os.path.dirname(path)
    self.stem = os.path.splitext(self.basename)[0]
  def exists(self): 
    return os.path.isfile(self.realpath)
  def __str__(self):
    return self.abspath

class out(datafile):
  pass

class image(datafile):
  def labels(self):
    l = os.path.join(self.path,'..','..',"{}_labels.mnc".format(self.stem))
    return os.path.exists(l) and abspath(l) or None

class taskset:
  def __init__(self):
    self.stages = defaultdict(list)
    self.stage_order = []
  def stage(self,stage_name):
    """syntactic sugar"""
    t = self
    class _stage(): 
      def command(self, *args):
        t.command(stage_name,args)
    return _stage()
  def command(self,stage,cmd):
    self.stages[stage].append(cmd)
    if stage not in self.stage_order: self.stage_order.append(stage)
  def set_stage_order(self, order):
    assert set(order).issubset(set(self.stages.keys)), "some stages given are not part of this taskset"
    self.stage_order = order
  def __str__(self):
    __str=""
    for stage in self.stage_order:
      __str += '{0}:\n'.format(stage)
      for command in self.stages[stage]:
        __str += '\t{0}\n'.format(' '.join(map(str,command)))
    return __str

def run_command(command): 
  cmdstr = " ".join(map(str,command))
  print >> sys.stderr, 'COMMAND:', cmdstr
  return call(cmdstr,shell=True)

class multiprocqueue:
  def run(self,tasks,processes=None,stage_order=None):
    """Runs the commands from the given stages in the task list.
       
       If stages isn't provided, then all stages are run. """
    stage_order = stage_order or tasks.stage_order
    for stage in stage_order:
      print '## stage:', stage,'##'

      results = self._run(tasks.stages[stage], processes)
      print 'results ---',results
      #TODO: assert that there were no errors
      if not all(map(lambda x: x==0,results)):
        print "Error in stage {0}. Exiting...".format(stage)
        return -1

  def _run(self,commands,processes=None): 
    unfinished, outputs = self._filter_unfinished(commands)

    # make output dirs directories
    map(mkdir_p, set(map(lambda x: x.dirname, chain(*outputs))))

    return Pool(processes).map(run_command, unfinished)

  def _filter_unfinished(self,commands):
    """returns tuple of each unfinished command, and a list of its output files"""
    details = [(c,filter(lambda x: isinstance(x,out),c)) for c in commands]
    unfinished, outputs = zip(*[(c,o) for (c,o) in details if 
      not all(map(lambda x: os.path.isfile(str(x)),o))])
    return (unfinished, outputs)

class Morphobits:
  def __init__(self):
    self._config = dict() # runtime configuration 
    self._config['output_dir']='output'
    self._config['reg_dir']   ='registrations'

  def xfmpath(self,images,name='nl.xfm'):
    args=[self._config['output_dir'],self._config['reg_dir']] + [i.stem for i in images] + [name]
    return os.path.join(*args)

  def build_pipeline(self,atlases,native_subjects,model,tasklist=None):
    tasklist = tasklist or taskset()
    subjects = []

    def stage(stage_name):
      return tasklist.stage(stage_name)
    
    def command(command,stage):
      tasklist.stage(stage).command(*command)

    # move to subjects to model space 
    for s in native_subjects:
      nuc=out('output/nuc/'+s.basename)
      xfm=out(self.xfmpath([model,s],name='lsq9.xfm'))
      modelsubject=out('output/modelspace/'+s.basename)
      command(('nu_correct','-quiet',s,nuc), stage='subject.nuc')
      stage('subject.model.prop').command('bestlinreg','-lsq9',nuc,model,xfm,modelsubject)
      subjects.append(image(modelsubject.path))
  
    # randomly select templates
    #templates = random.sample(subjects,int(0.3*len(subjects)))
    templates = filter(lambda x: x.stem in self._config['templates'],subjects)

    # do pairwise registrations between atlases and templates and subjects 
    for x,y in chain(product(atlases,templates), product(templates,subjects)):
      stage('pairwise.reg').command('mb_register',x,y,out(self.xfmpath([x,y])))

    # compute the average deformation to the model for each subject
    for s in subjects:
      grids=[]
      gridavg='output/gridavg/'+s.stem+'_grid.mnc'
      for a,t in product(atlases,templates):
        xfm=self.xfmpath([model,a,t,s])
        grid=os.path.dirname(xfm)+'/grid.mnc'
        stage('model.subject.xfm').command(
            'xfmjoin',self.xfmpath([model,a]),self.xfmpath([a,t]),self.xfmpath([t,s]),out(xfm))
        stage('model.subject.displace').command(
            'minc_displacement',model,xfm,out(grid))
        grids.append(grid)
      grids.append(out(gridavg))
      stage('model.subject.gridavg').command('mincaverage',*grids)
    return tasklist

def main():
  morpho  = Morphobits()
  morpho._config['templates'] = 'ADNI001,ADNI002,ADNI003'
  atlases = map(lambda x: image(x), glob.glob('input/atlases/brains/*.mnc')) #, #[image(str(x)+'atlas.mnc') for x in range(3)]
  subjects= map(lambda x: image(x), glob.glob('input/subjects/brains/*.mnc')) #[image(str(x)+'subject.mnc') for x in range(5)]
  model   = image(glob.glob('input/model/brains/*.mnc')[0]) # check there is only one!
  print 'atlases', map(str,atlases)
  print 'subjects', map(str,subjects)
  print 'model', model
  tasklist= morpho.build_pipeline(atlases,subjects,model)

  queue = multiprocqueue()
  queue.run(tasklist,processes=2)

if __name__ == '__main__': 
  main()
# subjects = modelspace/*
# templates = subset(subjects, 19)
# for x, y in product(atlases,templates) + product(templates,subjects):
#   reg-nl x y reg/x/y/nl.xfm
#
# for s in subjects:
#   for m,a,t,s in product(model,atlases,templates,s):
#     xfmjoin reg/m/a/nl.xfm reg/a/t/nl.xfm reg/t/s/nl.xfm reg/m/a/t/s/nl.xfm
#     minc_displacement model reg/m/a/t/s/nl.xfm grid.mnc
#   mincaverage product(model,atlases,templates,s)/grid.mnc deformation/s_grid.mnc
#
