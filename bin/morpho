#!/usr/bin/env python2.7
# vim: set ts=2 sw=2: 
from itertools import product, chain
from collections import defaultdict
from multiprocessing.dummy import Pool
from subprocess import call
import os, errno, random, glob, sys
import os.path
import argparse
from mbpipe import *
  
class Morphobits:
  def __init__(self):
    self._config = dict() # runtime configuration  #todo: temporary, replace
                                                   # with members

  def xfmpath(self,images,name='nl.xfm'):
    """Returns a standard path to an XFM file based on image names"""
    args=[self._config['output_dir'],self._config['reg_dir']] + [i.stem for i in images] + [name]
    return os.path.join(*args)

  def config(self, key, value=None):
    if value: 
      self._config[key] = value
    else:
      value = self._config.get(key,None)
    return value

  def build_pipeline(self,atlases,native_subjects,native_templates,model,tasklist=None):
    tasklist = tasklist or taskset()
    subjects = []
    templates = []
    output_dir=self.config('output_dir')

    # syntactic sugar for now
    def stage(stage_name):
      return tasklist.stage(stage_name)
    
    def command(command,stage):
      tasklist.stage(stage).command(*command)

    ## BEGIN
    # move to subjects and templates to model space 
    for s in set(native_subjects).union(set(native_templates)):
      nuc=out('output/nuc/'+s.basename)
      xfm=out(self.xfmpath([model,s],name='lsq9.xfm'))
      modelsubject=out('output/modelspace/'+s.basename)
      command(('nu_correct','-quiet',s,nuc), stage='subject.nuc')
      stage('subject.model.prop').command(
              'bestlinreg','-noverbose','-lsq9',nuc,model,xfm,modelsubject)
      if s in native_subjects:
        subjects.append(image(modelsubject.path))
      if s in native_templates:
        templates.append(image(modelsubject.path))
  
    # do pairwise registrations between atlases and templates and subjects 
    for x,y in chain(product(atlases,templates), product(templates,subjects)):
      stage('pairwise.reg').command('mb_register',x,y,out(self.xfmpath([x,y])))

    # do stuff with XFMs on all possible paths to subject
    for s in subjects:
      grids=list()
      objects=defaultdict(list)
      gridavg='{output_dir}/gridavg/{s.stem}_grid.mnc'.format(**vars())

      # compute all possible XFM paths to subject
      for a,t in product(atlases,templates):
        xfm=self.xfmpath([model,a,t,s])
        xfmdir=os.path.dirname(xfm)
        grid='{xfmdir}/grid.mnc'.format(**vars())
      
        # create single XFM for pathway (skip moves from identical images)
        xfms=[]
        for source,target in zip([model,a,t],[a,t,s]):
          if source != target:
            xfms.append(self.xfmpath([source,target]))
        assert xfms is not [], "{model}, {a}, {t}, {s} are all the same image?".format(**vars())
        xfms.append(out(xfm))
        stage('model.subject.xfm').command('xfmjoin',*xfms)

        # compute displacement along the pathway
        stage('model.subject.displace').command(
            'minc_displacement',model,xfm,out(grid))
          
        # transform objects from atlases
        if self.config('surface_area'):
          for o in a.objects():
            kind=o.stem
            object='${xfmdir}/${kind}'.format(**vars())
            stage('model.subject.objects.transform').command(
                'transform_objects',o,xfm,out(object))
            objects[kind].append(object)
        grids.append(grid)
    
      # compute the average XFM over all pathways to the subject
      grids.append(out(gridavg))
      stage('model.subject.gridavg').command('mincaverage',*grids)

      # calculate displacement of model objects 
      displacement_dir='{output_dir}/displacement'.format(**vars())
      for o in model.objects():
        obj_displace='{displacement_dir}/{s.stem}_{o.stem}.txt'.format(**vars())
        stage('model.subject.displacement').command(
                'object_volume_dot_product',o,gridavg,out(obj_displace))

      # operate on model..subject surfaces
      if self.config('surface_area'):
        for kind in objects.keys(): 
          # median surface per subject
          kind_dir  = '{output_dir}/{kind}'.format(**vars())
          medianobj = '{kind_dir}/{s.stem}_median.obj'.format(**vars())
          voronoi   = '{kind_dir}/{s.stem}_vorn.txt'.format(**vars())
          vorn_sa   = '{kind_dir}/{s.stem}_vorn_SA.txt'.format(**vars())

          stage('objects.median').command(
            "make_median_surfaces.pl",out(medianobj),*objects[kind])
          stage('objects.normals').command(
            "recompute_normals",medianobj,medianobj) #fix: not out()

          if self.config('voronoi'):
            # voronoi of median surface
            stage('objects.voronoi').command(
              'depth_potential', '-area_voronoi',medianobj,out(voronoi))

            #hack: determine the blurring kernal to use: 
            kernel = kind.startswith('gp_') and 3 or 5
            vorn_blur = '{kind_dir}/{s.stem}_vorn_SA_{kernel}mm_blur.txt'.format(
                **vars())

    return tasklist

def parse_args(): 
  parser = argparse.ArgumentParser()
  parser.add_argument("-n", dest="dry_run", default=False,
    action="store_true", help="Dry run. Show what would happen.")
  parser.add_argument("-j", "--processes", default=8, 
    type=int, metavar='N', help="Number of processes to parallelize over.")
  parser.add_argument("-s", '--subjects', nargs='+', default=None,
    help="A list of subjects to use (name of the brain image without .mnc extension)")
  parser.add_argument("-t", '--templates', nargs='+', default=(),
    help="A list of templates to use (name of the subject without .mnc extension)")
  parser.add_argument('-q', '--queue', choices=['parallel', 'qbatch', 'qbatch-sge'],
    default = 'qbatch', help="Queueing method to use")
  parser.add_argument("--output_dir", default="output", 
    type=os.path.abspath, metavar='', 
    help="Top-level folder for all output")
  parser.add_argument("--input_dir",   default="input", 
    type=os.path.abspath, metavar='', 
    help="Directory containing atlas, template and subject libraries")
  parser.add_argument("--reg_dir",   default="output/registrations", 
    type=os.path.abspath, metavar='',
    help="Directory containing registrations")
  parser.add_argument('--voronoi', default=False, action="store_true",
    help=argparse.SUPPRESS) #help="Compute voronoi partition of the median surface.")
  parser.add_argument('--show-pipeline', default=False, action="store_true",
    help="Show pipeline.")
  parser.add_argument('--write-to-script', default=False, action="store_true",
    help="Write a single script which reproduces the pipeline.")
  return parser.parse_args()
  
def user_error_if(condition, message): 
  if condition:
    print >> sys.stderr, message
    sys.exit(1)

def main():
  options = parse_args() 
  options.output_dir = os.path.abspath('output')
  options.reg_dir    = '{output}/registrations'.format(output=options.output_dir)
  options.input_dir  = os.path.abspath('input')
  options.model_dir  = '{input}/model'.format(input=options.input_dir)

  morpho  = Morphobits()
  morpho.config('output_dir',options.output_dir)
  morpho.config('reg_dir',   options.reg_dir)
  morpho.config('voronoi',   options.voronoi)

  # Get the model image 
  inmodeldir = glob.glob('{model}/brains/*.mnc'.format(model=options.model_dir))
  user_error_if(
    len(inmodeldir) != 1, "Expected one model image in {dir}/brains, but found {count}".format(
      dir=options.model_dir, count=len(inmodeldir)))
  model = image(inmodeldir.pop())

  # check that the model has objects (if needed)
  user_error_if(not model.objects(), 
      "Model objects expected in {0}, but found none.".format(options.model_dir))

  # get atlases
  atlases = map(image, glob.glob('input/atlases/brains/*.mnc'))
  if len(atlases) == 0:
    print >> sys.stderr, "WARNING: no atlases found, using model: {0}".format(model.abspath)
    atlases = [model]
  
  # todo: check that atlases have labels, objects, etc...

  # get model->atlas xfms
  model_atlas_xfms = dict()
  for atlas in atlases: 
    if atlas == model:
      xfm=None
    else:
      xfm='{model}/xfms/to_{atlas.stem}.xfm'.format(model=model.abspath,atlas=atlas)
      user_error_if(not os.path.isfile(xfm), 
        "Expected to find model->atlas xfm {0}".format(xfm))
    model_atlas_xfms[atlas] = xfm 
  model.atlas_xfms = model_atlas_xfms  #HACK monkey patch my own code? why not

  # subjects
  subjects=map(image, glob.glob('{0}/subjects/brains/*.mnc'.format(options.input_dir)))
  user_error_if(not subjects, "No subjects found in {0}/subjects/brains/".format(
    options.input_dir))

  # templates

  if options.templates:    
    templates = [s for s in subjects if s.stem in options.templates]
    user_error_if(not templates, "Templates specified not found in {dir}/subjects/brains/".format(
      dir=options.input_dir))
  else:
    templates=map(image, glob.glob('{0}/templates/brains/*.mnc'.format(options.input_dir)))
    user_error_if(not templates, "No templates found in {0}/templates/brains/".format(
      options.input_dir))
    
  if options.subjects:
    subjects = [s for s in subjects if s.stem in options.subjects]
  user_error_if(not subjects, "Subjects specified not found in {dir}/subjects/brains/".format(
    dir=options.input_dir))

  print 'model:\n\t{model.abspath}'.format(model=model)
  print 'atlases:\n\t', '\n\t'.join(map(str,atlases))
  print 'templates:\n\t', '\n\t'.join(map(str,templates))
  print 'subjects:\n\t', '\n\t'.join(map(str,subjects))
  tasklist= morpho.build_pipeline(atlases,subjects,templates,model)

  if options.queue == "qbatch": 
    queue = QBatchCommandQueue(processors=options.processes, batch='pbs')
  elif options.queue == "qbatch-sge": 
    queue = QBatchCommandQueue(processors=options.processes, batch='sge')
  elif options.queue == "parallel":
    queue = ParallelCommandQueue(processors=options.processes)
  else:
    queue = CommandQueue()
  queue.set_dry_run(options.dry_run)

  if options.show_pipeline:
    print tasklist

  if options.write_to_script:
    tasklist.write_to_script('script.sh', options.processes)

  tasklist.populate_queue(queue)
  if not queue.commands:
    print "Nothing to do."
  else: 
    tasklist.runqueue(queue, populate=False)

if __name__ == '__main__': 
  main()
